<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.os0day.cn</id>
    <title>OS0day</title>
    <updated>2022-04-04T06:46:17.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.os0day.cn"/>
    <link rel="self" href="https://blog.os0day.cn/atom.xml"/>
    <subtitle>欢迎来到这里，这是属于我自己的天地，希望你能够有所收获，四处游历的冒险者！</subtitle>
    <logo>https://blog.os0day.cn/images/avatar.png</logo>
    <icon>https://blog.os0day.cn/favicon.ico</icon>
    <rights>All rights reserved 2022, OS0day</rights>
    <entry>
        <title type="html"><![CDATA[前端之Webstorm的使用(Updating)]]></title>
        <id>https://blog.os0day.cn/post/Web001/</id>
        <link href="https://blog.os0day.cn/post/Web001/">
        </link>
        <updated>2022-02-17T15:44:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="webstorm使用整理">Webstorm使用整理</h1>
<h2 id="webstorm常用快捷键整理">Webstorm常用快捷键整理</h2>
<pre><code class="language-Html">1. ctrl + shift + n: 打开工程中的文件，目的是打开当前工程下任意目录的文件。
2. ctrl + j: 输出模板
3. ctrl + b: 跳到变量申明处
4. ctrl + alt + T: 围绕包裹代码(包括zencoding的Wrap with Abbreviation)
5. ctrl + []: 匹配 {}[]
6. ctrl + F12: 可以显示当前文件的结构
7. ctrl + x: 剪切(删除)行，不选中，直接剪切整个行，如果选中部分内容则剪切选中的内容
8. alt + left/right:标签切换
9. ctrl + r: 替换
10. ctrl + shift + up: 行移动
11. shift + alt + up: 块移动(if(){},while(){}语句块的移动)
12. ctrl + d: 行复制
13. ctrl + shift + ]/[: 选中块代码
14. ctrl + / : 单行注释
15. ctrl + shift + / : 块注释
16. ctrl + shift + i : 显示当前CSS选择器或者JS函数的详细信息
17. ctrl + '-/+': 可以折叠项目中的任何代码块，它不是选中折叠，而是自动识别折叠。
18. ctrl + '.': 折叠选中的代码的代码。
19. shift + esc: 当前激活的任意小窗口最小化，也可以是alt+数字键，数字在小窗口有显示。
20. alt + '7': 显示当前的函数结构。
21. 如果是*.html页面，则在文件名下的导航栏某DOM结构上右键，可以全选当前DOM结构。
22. 全局搜索 shift + shift
23. 全局文本搜索 ctrl + shift + f
24. ctrl + alt + 方向键 '&lt;——' 或者 '——&gt;' 回到之前访问的页面
</code></pre>
<h2 id="辅助webstorm解析vue目录结构的脚本">辅助Webstorm解析Vue目录结构的脚本</h2>
<p><a href="https://blog.csdn.net/crazy_jialin/article/details/106758721">Webstorm那些事 之 识别vue项目@根路径符号_crazy_jialin的博客-CSDN博客</a><br>
<a href="https://www.jianshu.com/p/5d42c667ee08">jetbrains: webstorm如何识别webpack中的@等alias符号 - 简书 (jianshu.com)</a></p>
<pre><code class="language-JavaScript">
//第一种自己配置
/** 
 该配置是给webstorm使用的,方便代码跳转  
 比如,@'/views/layout/components/DragBall'  
 ctrl + 鼠标左键 就可以跳转到代码的实现  
*/
const path = require('path')  
  
function resolve(dir) {  
 return path.join(__dirname, '.', dir)  
}  
  
module.exports = {  
 context: path.resolve(__dirname, './'),  
 resolve: {  
 extensions: ['.js', '.vue', '.json'],  
    alias:  {  
		 '@': resolve('src'),  
		      '@views': resolve('src/views'),  
		      '@comp': resolve('src/components'),  
		      '@core': resolve('src/core'),  
		      '@utils': resolve('src/utils')  
			} 
		  }
   }

//第二种 
const webpackConfig = require('@vue/cli-service/webpack.config.js')  
module.exports = webpackConfig

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端框架Vue调试]]></title>
        <id>https://blog.os0day.cn/post/Vue001/</id>
        <link href="https://blog.os0day.cn/post/Vue001/">
        </link>
        <updated>2022-02-16T11:54:47.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>参考自 ：<a href="https://www.cnblogs.com/JerryMouseLi/p/11032840.html">VUE程序调试的方法 - JerryMouseLi - 博客园 (cnblogs.com)</a></p>
</blockquote>
<h1 id="vue前端框架调试">Vue前端框架调试</h1>
<h1 id="控制台">控制台</h1>
<h2 id="11-添加consolelog指令">1.1 添加console.log指令</h2>
<p>在代码中添加console.log()方法，这里例子输出从数据库读回来的最高最低温，详见如下：<br>
<img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1606616-20190616203915326-1701770661.jpg.png" alt="" loading="lazy"></p>
<h2 id="12-调出界面如下">1.2 调出界面如下</h2>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1606616-20190616203924871-142682674.jpg.png" alt="" loading="lazy"></figure>
<h2 id="13-google浏览器的console窗口edge相同">1.3 Google浏览器的Console窗口（Edge相同）</h2>
<p>在Google浏览器中按F12，调出Console窗口如下。<br>
<img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1606616-20190616203931024-406784107.jpg.png" alt="" loading="lazy"></p>
<h2 id="14-consoleerror输出">1.4 console.error输出</h2>
<p>将代码改成Error输出如下<br>
<img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1606616-20190616203938283-831992557.jpg.png" alt="" loading="lazy"></p>
<h2 id="15-浏览器输出">1.5 浏览器输出</h2>
<p>则浏览器的Console输出会变成红色如下。<br>
<img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1606616-20190616203945310-2048294668.jpg.png" alt="" loading="lazy"></p>
<p><strong>如果输出的是一个JS对象或者数组，则需要用JSON.stringify方法将其转换成json数组再输出,如下<br>
<code>console.log(JSON.stringify(resolve));</code></strong></p>
<h1 id="alert">alert</h1>
<h2 id="21-alert方法代码">2.1 alert方法代码</h2>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1606616-20190616203952625-764198498.jpg.png" alt="" loading="lazy"></figure>
<h2 id="22-alert提示效果">2.2 alert提示效果</h2>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1606616-20190616204001962-1112393179.jpg.png" alt="" loading="lazy"></figure>
<p><strong>备注：alert方法为阻塞式，点击确定之后，前端代码才会继续运行</strong></p>
<h1 id="debuger">debuger</h1>
<h2 id="31-设置断点">3.1 设置断点</h2>
<p>设置断点debugger如下图<br>
<img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1606616-20190616204009181-1293854393.jpg.png" alt="" loading="lazy"></p>
<h2 id="32-运行代码">3.2 运行代码</h2>
<p>则运行代码之后，代码会自动跳到断点，停止运行如下<br>
<img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1606616-20190616204015565-1060766880.jpg.png" alt="" loading="lazy"></p>
<h2 id="33-输入关心的属性">3.3 输入关心的属性</h2>
<h3 id="331-watch中观察数据">3.3.1 Watch中观察数据</h3>
<p>Watch中点“+”,然后点击回车即可，看到对应数据的值。<br>
<img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1606616-20190616204022363-1168624898.jpg.png" alt="" loading="lazy"></p>
<h3 id="332-console中观察数据">3.3.2 Console中观察数据</h3>
<p>F12选择浏览器Console窗口，输入需要观察的变量名，点击回车，即可看到其对应值。<br>
<img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1606616-20190616204032091-1371851328.jpg.png" alt="" loading="lazy"></p>
<h2 id="34-输入想要执行的方法">3.4 输入想要执行的方法</h2>
<p>在断点设置，停止运行后，断点之前的方法可在Console窗口中运行输出。</p>
<h3 id="341-写一个调试方法output">3.4.1 写一个调试方法output()</h3>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1606616-20190616204039562-1738580065.jpg.png" alt="" loading="lazy"></figure>
<h3 id="342-设置断点并运行程序">3.4.2 设置断点并运行程序</h3>
<p>详见3.1，3.2</p>
<h3 id="343-执行方法运行程序">3.4.3 执行方法运行程序</h3>
<p>可观察到执行结果如下。<br>
<img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1606616-20190616204047493-1870546195.jpg.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[折腾小计之怎么有效利用手头的电子设备]]></title>
        <id>https://blog.os0day.cn/post/ztxj001/</id>
        <link href="https://blog.os0day.cn/post/ztxj001/">
        </link>
        <updated>2022-02-12T17:25:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="桌面好乱怎么办">桌面好乱怎么办？</h1>
<p>今天实在是忍无可忍了，我实在是受不了自己的桌面，总是要在成堆的快捷图标里面找自己想要打开的软件图标，由于图标比较密密麻麻，有时候竟然还会手抖点到其他软件去，真是心态爆炸“淦！&amp;··、**……”</p>
<p>于是我找去找了几个能够帮助我整理桌面的软件：<strong>Rolan</strong></p>
<h2 id="rolan">Rolan</h2>
<p>在使用该工具前：<br>
我的桌面下方的任务栏堆积了一堆软件，这么多的软件放在这里，既没有提高我打开软件的效率，又徒增我办公时候的软件摆放的混乱程度。<br>
<img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/Pasted%20image%2020220125232722.png" alt="" loading="lazy"><br>
使用后：<br>
我将常用的软件整理到了一起，这样要用的时候在去选择点击，让任务栏干净清爽多了<br>
<img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/Pasted%20image%2020220125234156.png" alt="" loading="lazy"></p>
<h1 id="如果你的手头恰好有个windows10以上的pad如何变成生产力呢">如果你的手头恰好有个Windows10以上的Pad,如何变成生产力呢</h1>
<p><img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/Pasted%20image%2020220210155352.png" alt="" loading="lazy"><br>
Windows10或者(windows11)在都是有这个<strong>连接</strong>的菜单选项的。Pad通过该连接模式可以被作为投屏的显示器。而我的Pad正是基于该模式，变成了一个可以触屏和键入代码的扩展设备了。</p>
<blockquote>
<p>注意点<br>
保证连接与被连接的设备在同一个局域网内.<br>
被连接的设备，需要设置一下接收连接即可.<br>
在主屏幕对扩展出来的屏幕做下调整（系统的显示菜单）.</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/Pasted%20image%2020220210160201.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[折腾小记之Git仓库的使用]]></title>
        <id>https://blog.os0day.cn/post/ztxj002/</id>
        <link href="https://blog.os0day.cn/post/ztxj002/">
        </link>
        <updated>2022-02-12T17:14:43.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>通过Git管理我实现了个人笔记与知识库的电子化</p>
</blockquote>
<h2 id="gitee使用小结">Gitee使用小结</h2>
<p><img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/Pasted%20image%2020220210115224.png" alt="" loading="lazy"><br>
这一年对于Gitee的使用，更多的是在用于对自己的工作笔记还有知识文档的管理，可以说这一年当中对于自身的专业提高记录了很多，总结了很多，但我感觉还是缺少一个东西，那就是对于自己专业能力的检验性的输出--demo、练手项目，还是不太够的，所以，这一年我会调整自己的方向多多加强这个方面的输出，让自己的专业提高可以形成一个不断推动自己向上的能力提升闭环。</p>
<h2 id="github使用小结">GitHub使用小结</h2>
<p><img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/Pasted%20image%2020220210115844.png" alt="" loading="lazy"><br>
然后与gitee相比较，GitHub的使用就少了些，提交记录是很少的。最近，我深感交流对于能力提升上的重要，所以，今后会开始加强对GitHub的使用，一些检验性的输出也会同步到GitHub上以便和志同道合的道友交流。</p>
<h2 id="为何要使用git仓库来管理自己的输出">为何要使用Git仓库来管理自己的输出</h2>
<blockquote>
<p>可能有些小伙伴会疑惑我为何要用仓库来进行管理自己的产出，那我在此就简要的讲解一下我对Git仓库使用上的认识。</p>
</blockquote>
<p>我们在工作之后会发现，学习与工作的生活实际上是混杂在一起的，没有所谓的单独一块时间是可以长时间投入在学习的，更多时候是工作的时候也在兼顾学习，学习的时候也在联系工作深入对工作的理解以便于提高工作的效率，两者不是非此即彼的。这样也就产生了一个问题<strong>工作与学习的产出是非常的零碎的</strong>，没有记录和整理的话，会发现很多东西会随着时间的延迟而慢慢遗忘，<strong>比如</strong>：<strong>两个明明很相似的场景，可是，原先的解决方案却怎么也想不起来，这样尴尬的场景是会经常发生的</strong>。如果可以进行有效的记录与管理的话，那么当我们遇到相似场景的时候，就可以快速的找出原先的解决方案，从而减少不必要的时间浪费，同样的道理也是适用在专业的学习上的，对于我的专业来说，专业上的学习成果最佳的体现是在工作上的运用，没有有效的记录与管理的时候，经常会出现的情况是<strong>知识断层</strong>，就是编程的过程当中突然想不起来某些API或者某些设计模式，从而导致自己不得不中断手头的工作，去翻阅文档或者面向百度编程，从而浪费了不必要的时间，假设你可以在对于业务理解充分并且各个编程的关键知识点的理解都是在线的，那么我觉得是可以在很短的时间内将工作任务完成掉的，从而，减少不必要的时间浪费，甚至是<strong>规避掉不必要的加班情况</strong>，总而言之，有效的记录和管理好处是很多。</p>
<h2 id="建立专业提升的学习闭环">建立专业提升的学习闭环</h2>
<p>这一年当中，我也通过Git仓库管理自己输出的同时，也在思考如何形成一个对自己的专业提升行之有效的方式方法，我总结出来的方式是通过：</p>
<pre><code class="language-txt">git仓库+txt(工作文档)+markdown(知识库)+demo/练手项目+电子资料/视频+工作总结
</code></pre>
<p>也就是**（理论学习&lt;==&gt;实践）双向模式**，与B站UP主<strong>技术胖</strong>所讲述的个人学习方法居然是想切合的，至少在现阶段可以证明自己的尝试方向是对的，但总体来说还有很多的不足，还需要在日后当中不断的实践与总结，才能越来越好，争取可以成为独当一面的<strong>技术大牛</strong>。<br>
<img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/Pasted%20image%2020220210153135.png" alt="" loading="lazy"></p>
<h2 id="构建一个交流地方">构建一个交流地方</h2>
<p>最近深感作为一名程序员，一名设计行业的工作者，交流对于我们自身的专业能力以及开阔自己的眼界是多么的重要，于是，我就创建了群聊，用于交流与相互学习，相当于一间互联网中的小茶馆，欢迎各位入座品茶☕<br>
<img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/Pasted%20image%2020220213011207.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划之爬楼梯]]></title>
        <id>https://blog.os0day.cn/post/algorithm001/</id>
        <link href="https://blog.os0day.cn/post/algorithm001/">
        </link>
        <updated>2022-02-03T10:09:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="01-概念讲解">01、概念讲解</h1>
<hr>
<blockquote>
<p>关于动态规划的资料很多，官方的定义是<strong>指把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解</strong>。概念中的<strong>各阶段之间的关系</strong>，其实指的就是<strong>状态转移方程</strong>。很多人觉得DP难（下文统称动态规划为DP），根本原因是因为<strong>DP跟一些固定形式的算法不同</strong>（比如DFS、二分法、KMP），它没有实际的步骤规定第一步、第二步来做什么，所以准确来说，<strong>DP其实是一种解决问题的思想</strong>。</p>
</blockquote>
<p>这种思想的本质是：<strong>一个规模比较大的问题</strong>（可以用两三个参数表示的问题），可以<strong>通过若干规模较小的问题的结果来得到</strong>的（通常会寻求到一些特殊的计算逻辑，如求最值等），如下图所示，一个大规模的问题由若干个子问题组成。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/guimo.png" alt="" loading="lazy"></figure>
<p>那么我们应该如何通过子问题去得到大规模问题呢？这就用到了<strong>状态转移方程</strong>（上面有介绍状态转移方程哦，不懂的请往上翻哦），我们一般看到的状态转移方程，基本都是这样：</p>
<pre><code>opt ：指代特殊的计算逻辑，通常为 max or min。

i,j,k 都是在定义DP方程中用到的参数。

dp[i] = opt(dp[i-1])+1

dp[i][j] = w(i,j,k) + opt(dp[i-1][k])

dp[i][j] = opt(dp[i-1][j] + xi, dp[i][j-1] + yj, ...) 
</code></pre>
<p>每一个状态转移方程，多少都有一些细微的差别。这个其实很容易理解，世间的关系多了去了，不可能抽象出完全可以套用的公式。所以我个人其实<strong>不建议去死记硬背各种类型的状态转移方程</strong>。但是DP的题型真的就完全无法掌握，无法归类进行分析吗？我认为不是的。在本系列中，我将由简入深为大家讲解动态规划这个主题。</p>
<h1 id="02-题目分析">02、题目分析</h1>
<hr>
<p>我们先看一道最简单的DP题目，熟悉DP的概念：</p>
<table>
<thead>
<tr>
<th>第70题：爬楼梯</th>
</tr>
</thead>
<tbody>
<tr>
<td>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ **注意：**给定 <em>n</em> 是一个正整数。</td>
</tr>
</tbody>
</table>
<p><strong>示例 1：</strong></p>
<pre><code>输入： 2   输出： 2  解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶 
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入： 3   输出： 3  解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶 
</code></pre>
<h1 id="03-图解分析">03 、图解分析</h1>
<hr>
<p>通过分析我们可以明确，该题可以被分解为一些包含最优子结构的子问题，即它的<strong>最优解可以从其子问题的最优解来有效地构建</strong>。满足“<strong>将大问题分解为若干个规模较小的问题</strong>”的条件。所我们令 <strong>dp[n] 表示能到达第 n 阶</strong>的方法总数，可以得到如下状态转移方程：</p>
<blockquote>
<p><strong>dp[n]=dp[n-1]+dp[n-2]</strong></p>
</blockquote>
<ul>
<li>
<p>上 1 阶台阶：有1种方式。</p>
</li>
<li>
<p>上 2 阶台阶：有1+1和2两种方式。</p>
</li>
<li>
<p>上 3 阶台阶：到达第3阶的方法总数就是到第1阶和第2阶的方法数之和。</p>
</li>
<li>
<p>上 n 阶台阶，到达第n阶的方法总数就是到第 (n-1) 阶和第 (n-2) 阶的方法数之和。</p>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/moxing.png" alt="" loading="lazy"></figure>
<h2 id=""><a href="#_04%E3%80%81go%E8%AF%AD%E8%A8%80%E7%A4%BA%E4%BE%8B">#</a> 04、GO语言示例</h2>
<p>根据以上分析，可以得到代码如下：</p>
<pre><code class="language-Go">func climbStairs(n int) int {
	if n == 1 {
		return 1
	}
	dp := make([]int, n+1)
	dp[1] = 1
	dp[2] = 2
	for i := 3; i &lt;= n; i++ {
		dp[i] = dp[i-1] + dp[i-2]
	}
	return dp[n]
} 
</code></pre>
<pre><code class="language-Go">// 占用内存更少的方案

func climbStairs(number int) int {
    if number == 1 {
        return 1
    }
    if number == 2 {
        return 2
    }
    dp := [2]int{
        1, 2,
    }
    for i := 3; i &lt;= number; i++ {
        dp[0], dp[1] = dp[1], dp[0]+dp[1]
    }
    return dp[1]
}
</code></pre>
<blockquote>
<p>参考来源为：<a href="https://www.geekxh.com/1.2.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/201.html#_01%E3%80%81%E6%A6%82%E5%BF%B5%E8%AE%B2%E8%A7%A3">爬楼梯(70) | 小浩算法 (geekxh.com)</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于Gridea同步失败的解决方案（亲测目前有效）]]></title>
        <id>https://blog.os0day.cn/post/gridea001/</id>
        <link href="https://blog.os0day.cn/post/gridea001/">
        </link>
        <updated>2022-01-29T04:31:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>该文章转载自<a href="https://blog.gd1214b.icu/post/F2_C5EVQh/" title="解决Gridea同步失败的问题">https://blog.gd1214b.icu/post/F2_C5EVQh/</a></p>
</blockquote>
<p>由于众所周知的原因，GitHub在中国大陆地区受到的干扰严重，大部分情况下根本无法连接，这也导致Gridea的同步失败问题。<br>
<img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1623391923562.png" alt="" loading="lazy"></p>
<h1 id="解决方案">解决方案</h1>
<p>通常的解决方案是通过代理服务器连接，但由于大部分的代理软件（如v2rayN等），只能更改系统的代理设置，像Gridea这些不遵守系统代理设置的软件，无法通过代理服务器连接。<br>
下面介绍一种本人亲测有效的方法, 这种方法的基本原理是用GitHub Desktop将Gridea生成的网页源代码手动push到GitHub上。</p>
<h2 id="第一步-连接上代理">第一步 连接上代理</h2>
<p><strong>有各种代理工具，有免费的也有自建的，或者，修改本地Host文件，等等，在此就不多赘述了。</strong></p>
<h2 id="第二步-下载并安装github-desktop">第二步 下载并安装GitHub Desktop</h2>
<p>下载地址：<br>
<a href="https://central.github.com/deployments/desktop/desktop/latest/win32">https://central.GitHub.com/deployments/desktop/desktop/latest/win32</a><br>
打开安装程序即可自动完成安装。</p>
<h2 id="第三步-登陆github账号">第三步 登陆GitHub账号</h2>
<ol>
<li>点击 Sign into GitHub.com<br>
<img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1623481745688.jpg" alt="" loading="lazy"></li>
<li>在浏览器里登陆你的GitHub账号<br>
<img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1623481982934.jpg" alt="" loading="lazy"></li>
</ol>
<h2 id="第四步-清空gridea-配置目录下ouput文件夹里的所有内容">第四步 清空Gridea 配置目录下ouput文件夹里的所有内容</h2>
<blockquote>
<p>需要清空ouput文件夹里的所有内容的原因是GitHub Desktop无法克隆仓库到非空文件夹中，这一步不会影响你的博客数据。</p>
</blockquote>
<p><strong>注意output文件夹不要删除</strong><br>
<img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1623482115749.jpg" alt="" loading="lazy"></p>
<h2 id="第五步-在github-desktop中克隆你的博客仓库">第五步 在GitHub Desktop中克隆你的博客仓库</h2>
<p><img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1623482247255.jpg" alt="" loading="lazy"><br>
注意目录要选择Gridea 配置目录下ouput文件夹<br>
<img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1623482322654.jpg" alt="" loading="lazy"></p>
<h2 id="第六步-同步gridea">第六步 同步Gridea</h2>
<p>在Gridea中依次点击 远程 &gt; 检测远程连接 &gt; 同步<br>
这一步无所谓是否同步成功.<br>
<img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1623482746893.jpg" alt="" loading="lazy"></p>
<h2 id="第七步-同步到github上">第七步 同步到GitHub上</h2>
<p>在GitHub Desktop 中点击 Pushu origin<br>
<img src="https://cdn.jsdelivr.net/gh/OS0day/MyImagesBed@latest/images/1623482930640.jpg" alt="" loading="lazy"><br>
等候完成即可。</p>
<blockquote>
<p>根据评论区中某匿名网友的提醒，有change files的话需要先点击左下角的Commit，才会出现第七步截图里的push origin。</p>
</blockquote>
<h1 id="其他说明">其他说明</h1>
<p>此时你的博客应该已经同步到GitHub上了，如果有任何问题，欢迎在下方的评论区中提出。</p>
<ul>
<li><strong>本文作者：</strong> gd1214b</li>
<li><strong>本文链接：</strong> <a href="https://blog.gd1214b.icu/post/F2_C5EVQh/" title="解决Gridea同步失败的问题">https://blog.gd1214b.icu/post/F2_C5EVQh/</a></li>
<li><strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL之SQLServer存储过程简单样例(Updating)]]></title>
        <id>https://blog.os0day.cn/post/sql001/</id>
        <link href="https://blog.os0day.cn/post/sql001/">
        </link>
        <updated>2022-01-28T16:17:22.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-SQL">--带参存储过程  
if (object_id('proc_find_stu', 'P') is not null)  
    drop proc proc_find_stu  
go  
create proc proc_find_stu(@startId int, @endId int)  
as  
    select * from student where id between @startId and @endId  
go  
  
exec proc_find_stu 2, 4;
</code></pre>
<pre><code class="language-sql">--创建存储过程  
if (exists (select * from sys.objects where name = 'proc_get_student'))  
    drop proc proc_get_student  
go  
create proc proc_get_student  
as  
    select * from student;  
  
--调用、执行存储过程  
exec proc_get_student;
</code></pre>
<pre><code class="language-SQL">--带通配符参数存储过程  
if (object_id('proc_findStudentByName', 'P') is not null)  
    drop proc proc_findStudentByName  
go  
create proc proc_findStudentByName(@name varchar(20) = '%j%', @nextName varchar(20) = '%')  
as  
    select * from student where name like @name and name like @nextName;  
go  
  
exec proc_findStudentByName;  
exec proc_findStudentByName '%o%', 't%';
</code></pre>
<pre><code class="language-SQl">-- 输出参数的存储过程
if (object_id('proc_getStudentRecord', 'P') is not null)  
    drop proc proc_getStudentRecord  
go  
create proc proc_getStudentRecord(  
    @id int, --默认输入参数  
    @name varchar(20) out, --输出参数  
    @age varchar(20) output--输入输出参数  
)  
as  
    select @name = name, @age = age  from student where id = @id and sex = @age;  
go  
  
--   
declare @id int,  
        @name varchar(20),  
        @temp varchar(20);  
set @id = 7;   
set @temp = 1;  
exec proc_getStudentRecord @id, @name out, @temp output;  
select @name, @temp;  
print @name + '#' + @temp;
</code></pre>
<pre><code class="language-sql">-- 不缓存的存储过程
--WITH RECOMPILE 不缓存  
if (object_id('proc_temp', 'P') is not null)  
    drop proc proc_temp  
go  
create proc proc_temp  
with recompile  
as  
    select * from student;  
go  
  
exec proc_temp;
</code></pre>
<pre><code class="language-sql">--加密WITH ENCRYPTION   
if (object_id('proc_temp_encryption', 'P') is not null)  
    drop proc proc_temp_encryption  
go  
create proc proc_temp_encryption  
with encryption  
as  
    select * from student;  
go  
  
exec proc_temp_encryption;  
exec sp_helptext 'proc_temp';  
exec sp_helptext 'proc_temp_encryption';
</code></pre>
<blockquote>
<p>在前面介绍游标的例子中，SELECT语句都没有WHERE子句，或者用WHERE子句指定了一个固定的条件，这样每次都查询同样的数据。在更多的情况下，可能要根据实际情况查询不同的数据。为了通过游标对数据进行更加灵活的处理，可以为游标定义参数，这些参数可以用在WHERE子句中。在打开游标时，指定实际的参数值，这样游标在每次打开时，可以根据不同的实际参数值，返回所需的不同数据。</p>
</blockquote>
<pre><code class="language-sql">-- 带游标参数的存储过程
if (object_id('proc_cursor', 'P') is not null)  
    drop proc proc_cursor  
go  
create proc proc_cursor  
    @cur cursor varying output  
as  
    set @cur = cursor forward_only static for  
    select id, name, age from student;  
    open @cur;  
go  
--调用  
declare @exec_cur cursor;  
declare @id int,  
        @name varchar(20),  
        @age int;  
exec proc_cursor @cur = @exec_cur output;--调用存储过程  
fetch next from @exec_cur into @id, @name, @age;  
while (@@fetch_status = 0)  
begin  
    fetch next from @exec_cur into @id, @name, @age;  
    print 'id: ' + convert(varchar, @id) + ', name: ' + @name + ', age: ' + convert(char, @age);  
end  
close @exec_cur;  
deallocate @exec_cur;--删除游标
</code></pre>
<pre><code class="language-sql">---存储过程、row_number完成分页  
if (object_id('pro_page', 'P') is not null)  
	drop proc proc_cursor  
go  
create proc pro_page  
    @startIndex int,  
    @endIndex int  
as  
    select count(*) from product  
;      
    select * from (  
        select row_number() over(order by pid) as rowId, * from product   
    ) temp  
    where temp.rowId between @startIndex and @endIndex  
go  
drop proc pro_page  
exec pro_page 1, 4  
--  
--分页存储过程  
if (object_id('pro_page', 'P') is not null)  
    drop proc pro_stu  
go  
create procedure pro_stu(  
    @pageIndex int,  
    @pageSize int  
)  
as  
    declare @startRow int, @endRow int  
    set @startRow = (@pageIndex - 1) * @pageSize +1  
    set @endRow = @startRow + @pageSize -1  
    select * from (  
        select *, row_number() over (order by id asc) as number from student   
    ) t  
    where t.number between @startRow and @endRow;  
  
exec pro_stu 2, 2;

</code></pre>
<blockquote>
<p>SQL Server 修改存储过程<br>
如果需要修改现有的存储过程，只需更换掉 CREATE ，使用 ALTER。<br>
我们在 “Latest” 和 “Tasks”间添加一个空格（即“Latest Tasks”），并添加描述字段，如下</p>
</blockquote>
<pre><code class="language-sql">ALTER PROCEDURE LatestTasks @Count int 
AS 
SET ROWCOUNT @Count 
SELECT TaskName AS &quot;Latest Tasks&quot;, Description, DateCreated FROM Tasks 
ORDER BY DateCreated DESC
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[提高执行力的学习之剖析个人问题和思考提高执行力的方法]]></title>
        <id>https://blog.os0day.cn/post/execution001/</id>
        <link href="https://blog.os0day.cn/post/execution001/">
        </link>
        <updated>2022-01-22T16:04:10.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>正式踏入职场工作的萌新，这正式工作的半年当中我在导师以及身边的同事的帮助和引导下，在软件开发的领域有取得一些进步，在进步的同时也发现了自身存在诸多方面的问题。面对这些问题，我尝试过去改正，  但是改正的结果却总是差强人意，我也一时间也难以搞明白是什么原因造成的，片面的归结于是个人经验所限造成的。随着工作时间的延长，我逐渐意识到一点“盲目与片面以及思想上的混乱、行动上的无序”才是这一切问题发生的根源。<br>
简单来说，就是缺乏指导自己前行的科学方式、方法。</p>
<h2 id="一-发现自身问题是进步的关键"><strong>一、发现自身问题是进步的关键</strong></h2>
<p>在《华为执行力》这边书当中有罗列了很多的案例以及对应的方式方法，这些都是他们华为人的经验所得，但是是否<br>
适合自己，这是首先要去怀疑的。我个人认为只有结合自己的情况，加以改进适配的方案才是最优的。<br>
个人所存在的问题:</p>
<h3 id="一存在很多错误的观念"><strong>（一）存在很多错误的观念</strong></h3>
<p>1、没有以结果未导向，片面重视做的过程。<br>
在实际的工作当中，企业更为侧重的工作结果，而非校园当中那样去侧重学习与研究即使是没有任何收获也没有关系。</p>
<p>2、没有从考虑可以带来多少实际生产力来考虑新知识的学习。<br>
在校园当中是比较发散的，可以学习任何自己所感兴趣的，可以进行深度的学习，也可以粗略的学习；而对于企业来说学习是具有较强的针对性的，高度需要对某些领域有深入的研究，并带到实际的工作当中去转换为实际的生产力，要有  实际的产出，奉行高度的实用主义。</p>
<p>3、没有重视团队协作。<br>
在企业当中奉行的是团队主义，大家一起沟通协作力求可以快速且保质保量的完成工作。而在<br>
校园当中，团队协作的观念培养，我是比较不重视的，经常自己学习、自己处理遇到的难题，也就早就了我比较“个人主义”的问题。在面对问题  的时候我往往是先思考自己要怎么去解决，经过冥思苦想来得到解决方案，如果没有得到解决方案才会对外向老师或者专业里更为优秀的同学请<br>
教，奉行“自己解决的才是自己的”思想观念，然而，实际的工作确是与之想反的，企业需要的  是团队主义，大家在一起工作就是为了更快、更好的完成工作。团队当中一般都有积累了很多的解决方案，或者，团队当中存在工作经验比较丰富的大牛，在遇到问题可以提供一个较为优质的建议，甚至是好的解决方案，这个时候就可以  给工作的推进带来极大的帮助，从而避免重复造“轮子的问题”。</p>
<p>4、没有严谨的论证思维，对于自己的推理没有经过验证就觉得合理可行，实际上却是漏洞百出而不察。更多的时候，我都是通过主观臆断的方式，来看待所面对的问题，看待的场景片面化，理论依据的立足点没有经过验证  就以此为论据，最好出现与所想不同的问题，导致需要重新花时间去分析问题处理问题，做了很多的无用功。论证思维培养是需要多学习科学研究的分析方式方法以及<br>
多请教前辈同事，来丰富自己的分析与论证问题的经验，不断增加自己  考虑与分析问题的维度。</p>
<p>5、存在“想当然”的情况。<br>
没有确认什么是完成的标准，就盲目认为任务完成了，业务需求没有反复确定自己理解的是否是正确的，就想当然认为自己明白了，最后做出来偏差了，验证的时候出现问题了，才不得不去重新论证与改造；任务相当然的认为做完就好，没有去总结“怎么样才是做好、怎么做可以更好、如何做可以效率更高，等等”，做到快完成  的时候，就相当地认为差不多了，没有验证就认为好了，出问题了，又不得不再次返工，既没有效率又没有质量，还破坏了团队对自己的信任。</p>
<p>6、没有意识的去规划自己的时间，没有结合工作任务的优先级来分配工作任务，忽视了每项工作完成时间的控制。</p>
<h3 id="二专业能力提高上没有明确的规划"><strong>（二）专业能力提高上没有明确的规划</strong></h3>
<p>1、没有有意识去积累解决方案：如，表设计、如何将业务逻辑抽象出来，实现复用、架构如何设计。<br>
2、没有去制定有效且系统的训练与长期学习计划<br>
3、业务梳理上缺少对业务快速理解和应用的策略。<br>
4、分析问题（数据、代码设计与审计、表结构设计与审计、业务关联与分析，等）<br>
5、问题定位（复现以及快速修复）</p>
<h2 id="二-在结合自身情况的基础上总结合适的改进方案推动进步"><strong>二、在结合自身情况的基础上总结合适的改进方案推动进步</strong></h2>
<p>在上述的问题当中，我将问题归类为两类：1、错误的观念；2、没有明确的规划。对于我个人来说，要想有明显的进步，就必须着手将这两大问题解决。</p>
<h3 id="一错误的观念改如何有效纠正"><strong>（一）错误的观念改如何有效纠正</strong></h3>
<p>观念可以说是行为习惯，伴随着自身比较久的，需要有意识的去做问题的规避，才能有效的纠正。通过笼统的方式来纠正行为习惯上的问题是行不通的，个人认为需要通过流程化的方式来规范自己的日常工作，让行为习惯在养成规范化的工作方式的同时，完成对自身行为习惯的纠正。<br>
在《华为执行力》书中，第65页“养成规范化的工作习惯”，恰好与我的观点想契合。规范化的工作习惯是为了规避个人行为习惯、错误观念对工作效率的影响，同时，实现对工作进行有效的监控，让工作可以高效的完成。书中列举了，华为的<strong>秩序化工作法则</strong>，该法则让华为的员工养成了秩序化工作的好习惯，但是，在执行的过程中，容易出现员工将个人的思想观念或者个人习惯带入到工作任务当中的问题，人为的改变了工作标准，按照自身的思路去做事情，然后，导致工作偏离了正确的轨道；为了解决该问题，华为对员工的要求是：严格按照工作流程标准进行，并对各个关键节点的执行情况进行监控，以确保工作任务是按照计划开展的，并以此为基础再进一步提高效率。</p>
<p><strong>秩序化工作法则</strong>的核心在于用详细的操作流程规范化工作、用严谨科学的操作方案来减少执行上的问题。我的工作是软件开发，那么我该围绕着什么来制定自己的工作规范呢？软件开发是围绕的业务需求展开，将业务需求抽象为代码逻辑，工作的要点在于个人要完成分配的工作，同时，也需要配合同事推动团队的工作计划。针对于此，我想对于我来说工作规范化的要点在于：如何梳理业务需求与确认需求、业务需求转化为代码逻辑所需要的注意的点（代码逻辑实现的效果是否和业务需求一致）、如何高效的完成个人工作以及配合团队推动工作计划、如何及时反馈工作中遇到的问题（个人工作是团队工作推进的一个节点，节点堵塞，势必会影响到整体工作的推进）。</p>
<p><strong>制定自己的规范化工作流程（在后续工作当中不断完善）</strong>：</p>
<ul>
<li>
<p>梳理需求与确认需求（在工作开展前就保证工作方向是正确，避免返工的问题）<br>
将需求梳理好之后，将自己的对需求的理解，以文字的形式（文字也是对需求的二次梳理以便于加强自己对业务的理解）  反馈给需求提供方，以确保自己的理解是没有错误的，如果有错误也能及时纠正。</p>
</li>
<li>
<p>将业务需求转化为正确的代码逻辑<br>
通过思维导图的方式，将所要做工作点进行罗列，对数据实体关系进行分析，用切合业务场景的方案来处理，将自己的整理出来的工作方案和同事进行交流，已确保设计思路实现的效果可以满足业务需求，同时，又可以保留有一定的兼容性，以便于后续功能的扩展。</p>
</li>
<li>
<p>提早与同事交流沟通好，确定需要配合的点，以确保工作对接可以顺利进行。</p>
</li>
<li>
<p>确定工作完成的标准，以及需要达到的效果，不能模棱两可。<br>
工作具体要完成哪些东西才算是完成：业务需求是否满足、配合其他同事需要的设计是否做了，罗列的工作点是否都完成了，等；<br>
分析与验证的时候，要明确目的，以及预期的结果，还有验证的标准。</p>
</li>
<li>
<p>对工作的时间要进行把控，减少不必要的时间浪费。<br>
耗时较长没有解决工作问题的情况，就需要及时反馈，该请教问题就去请教问题，该反馈问题就反馈问题，力求将影响工作进度的情况尽早扼杀在摇篮当中。</p>
</li>
<li>
<p>个人工作完成后，进行检查和复盘以确保工作完成的质量，做好自测验证编写的代码逻辑是否满足业务需求，是否满足同事的需要，思考工作当中存在的问题点，记录并在后续的工作当中进行改进。</p>
</li>
</ul>
<h3 id="二如何提升自身的专业水平"><strong>（二）如何提升自身的专业水平</strong></h3>
<p>个人认为专业提升的有效途径可以归结为：基础训练、工作当中积累解决方案以工作之余扩充积累解决方案、学习如何有效地梳理业务以及用代码逻辑对业务进行转化、学习如何分析问题、定位问题、解决问题。<br>
在专业提升当中可以做的事情：</p>
<ul>
<li>
<p>基础训练<br>
算法题目训练、常用技术栈demo、个人玩具项目</p>
</li>
<li>
<p>积累解决方案<br>
从实际工作当中去记录和整理遇到的场景，整理为通用的模型；  从网络学习，学习优秀的架构设计理念以及常用的解决方案模式</p>
</li>
<li>
<p>业务的梳理<br>
需要不断的加强对业务的理解，与SM、产品、同事多探讨业务上的理解问题，通过交流的方式来加深自己对业务的理解  以及将业务当中存在的理解误区找出来并纠正。</p>
</li>
<li>
<p>分析问题、定位问题、解决问题<br>
问题的立足点是在于实际的业务，理解清楚业务确定好问题各个影响因素与前置条件为基础，才能将把控好问题分析的  方向，方向正确了才能有正确结论的得出。</p>
</li>
<li>
<p>交流是专业提升的有效途径。<br>
社区文章输出、同事之间的专业问题的交流，等</p>
</li>
</ul>
<p>制定的改进方案也是需要根据自己当下的实际情况来的，虽然我在上文描述了很多设想，以及思考了后续要怎么去做，但这毕竟也只是设想的，是一种理想化的场景。在现阶段下，自己是没有办法做到尽善尽美的，需要在实践当中去思考与验证。对于按照流程化的工作方法，以及专业能力提升上的计划与践行，是需要自己平时落实到具体的细节处，具体去思考怎么去做才好，需要找出最为突出的矛盾点并加以解决，而非像只是做这样大体的规划，还是应当需要将一个个小的问题处理好，避免重复犯错的情况下，去实现一个个短期目标来做支撑，并在这个过程当中培养和完善自己，才能最终才能够实现这样通过科学的、流程化的方式来提高工作或者专业学习的效率。</p>
<p>有所总结与领悟，同时，也要在日后的工作当中不断严格要求自己，让自己可以将改进方案扎实地落实到位，才能从根本上去解决自身的问题，并且不能急躁，需要一步一个脚印，坚持做好每一步，才会有水滴石穿之效！与诸君共勉！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GO之基础语法的学习一]]></title>
        <id>https://blog.os0day.cn/post/goStudy001/</id>
        <link href="https://blog.os0day.cn/post/goStudy001/">
        </link>
        <updated>2022-01-09T08:12:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-demo-之常用变量类型以及函数">一、Demo 之常用变量类型以及函数</h1>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

var testNumber = 20

func main() {
	//var  _age int = 123
	var _age = 24
	datetime := time.Now()
	fmt.Println(&quot;Hello, Go! I'm &quot;,_age,&quot;year's old&quot;,&quot;当前时间&quot;,datetime)
	fmt.Println(&quot;当前时间&quot;,datetime)
	max(12,11)
}

func max(num1,num2 int) {
	var result = num1 + num2 + testNumber
	//getString :=[...]string{}
	var getString[12] string
	for  i := 0 ; i &lt; 10 ; i++{
		result += i
		fmt.Println(i,&quot;测试一下循环输出&quot;)
		getString[i] = fmt.Sprintln(i,&quot;测试一下字符串数组的赋值&quot;)
	}
	fmt.Println(result,&quot;这个是字符串数组:&quot;,getString)
	fmt.Println(fmt.Sprintln(ReturnResultAndGetString(20,21)),&quot;测试一下函数的返回值&quot;)
	fmt.Println(&quot;测试一下函数的返回值&quot;,fmt.Sprintln(ReturnResultAndGetString(20,21)),&quot;&quot;)
	fmt.Println(&quot;测试返回值不同的使用方式&quot;,fmt.Sprintln(ReturnResult(20,21)),&quot;&quot;)
}

func ReturnResultAndGetString(num1,num2 int) (result int,getString[12] string){
	 result = num1 + num2 + testNumber
	//getString :=[...]string{}
	for  i := 0 ; i &lt; 10 ; i++{
		result += i
		fmt.Println(i,&quot;测试一下循环输出&quot;)
		getString[i] = fmt.Sprintln(i,&quot;测试一下字符串数组的赋值&quot;)
	}
	fmt.Println(result,&quot;这个是字符串数组:&quot;,getString)


	return
}

func ReturnResult(num1, num2 int) (int, [12]string) {
   var result = num1 + num2 + testNumber
	//getString :=[...]string{}
	var getString[12] string
	for  i := 0 ; i &lt; 10 ; i++{
		result += i
		fmt.Println(i,&quot;测试一下循环输出&quot;)
		getString[i] = fmt.Sprintln(i,&quot;测试一下字符串数组的赋值&quot;)
	}
	fmt.Println(result,&quot;这个是字符串数组:&quot;,getString)
	return result,getString
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021年终总结]]></title>
        <id>https://blog.os0day.cn/post/2021-summary/</id>
        <link href="https://blog.os0day.cn/post/2021-summary/">
        </link>
        <updated>2022-01-08T15:09:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="引言">引言</h1>
<p>时间飞快，转眼 2021 年已经过去了，我的学生生涯也已经正式结束了将近半年时间。</p>
<p>不得不感叹一件事情，那就是“时间飞快”，正式工作的这段时间<br>
，时间流逝的速度仿佛加了倍速一样，快速地在流逝着，</p>
<p>当我把这个感受和朋友讨论的时候，他们也是有相似的感受，都在感叹时间飞快。为何会有这样的感受呢，</p>
<p>我自己是把它的原因归结于工作的忙碌以及对前途的焦虑。工作的忙碌让我们没有偷闲的时间，不像是在大学校园里那样，</p>
<p>只要不是考试周，就有很多偷闲的时间；在校园的我们也没有去焦虑未来要如何如何，更多还是在享受大学的生活、享受那种没有拘束的快乐；</p>
<p>而当我们走出校园之后，生活的压力、工作的压力快速向我们压力的时候，初来乍到的我们，就像是到了一个游戏世界的新手村一样，既兴奋又充满了焦虑和紧张，</p>
<p>于是，笨拙的我们开始去思考如何在这样的世界生存、如何去追寻自己想要的生活。我觉得该如果生活该追寻什么、该做些什么，应该立足于自身当下。</p>
<h1 id="一-2021-年下半年所做的事情">一、 2021 年下半年所做的事情</h1>
<ul>
<li>在杭州一家知名的医疗器械科技公司工作，从事软件开发，成为一名初级的软件工程师。</li>
<li>在正式工作的半年当中，跌跌撞撞地学习如何成为一名专业的软件工程师。</li>
<li>在团队协作当中发现自己存在的问题，适应工作团队协作的模式。</li>
</ul>
<h1 id="二-总结自身专业上存在的问题">二、总结自身专业上存在的问题</h1>
<h2 id="1理念问题">1）理念问题</h2>
<p>正式的工作，让我深刻的体会到了校园所学与企业所需的深刻差异，校园中的养成的一些思想和理念与企业的思想和理念是不相同的，甚至是冲突的。</p>
<ul>
<li>
<p>对于工作来说，企业更侧重的是工作结果，而在校园里更侧重的学习与研究带来的收获。</p>
</li>
<li>
<p>对于新知识的学习，在校园是比较发散的，你可以去学习任何你所感兴趣的，可以进行深度研究，也可以粗略学习，而对于企业而言，学习是具有针对性的，高度需要对某些领域有深入的研究，是需要能够转换为实际的生产力，要有实际产出，是高度的实用主义的。</p>
</li>
<li>
<p>协作，在<strong>校园</strong>盛行的是<strong>个人主义</strong>，而在<strong>企业</strong>则是<strong>团队主义</strong>，大家一起沟通协作来快速将工作保质保量的完成。<br>
这个个人主义，给我的工作带来了很大的麻烦，对于，我这样一个在校园内，喜欢自己人研究工科问题的我来说，如果去解决问题，我往往最先是思考自己将如何去解决问题，若思考无解，<br>
才是带着疑虑去请教别人问题，奉行 “自己解决的才是自己” 的思想观念，然而，实际的工作却是相反的，在企业中需要的是团队主义，大家一起工作的目的：<strong>是为了快速且高质量地完成工作</strong>，<br>
对于，团队已经遇到过并且解决的问题，有现成的解决方案只要是符合使用场景的，变可以直接拿过来用；对于，初入团队中的我来说，我并不清楚团队到底积累了多少解决方案，同时，我又是<br>
高度奉行个人主义的人，这样就造成了，对于开发任务中有现成解决方案的场景重复“造轮子”浪费了不必要浪费的时间，这样就直接造成了需要的开发时间增加了，甚至造成拖延整个团队的工作进度。</p>
</li>
<li>
<p>缺乏严谨的论证思维，对于自己的推理自己觉得合理，实际却漏洞百出而不察！<br>
我并不清楚，到底是自己所在校园教学环境的问题，还是，高校普遍都存在这样的问题——没有专业的实验室或者是工作室来培养学生的论证思维。<br>
回顾校园的学习，我发现自己更多是在用主观臆断的方式来看待所面对的问题，看待场景片面化，理论依据的立足点没有验证就拿来当做依据，等等诸多问题。</p>
</li>
<li>
<p>随着心情做事情，认为好的情绪才有好的工作与学习状态。<br>
实际上，这是很不成熟的想法，情绪好与坏不是不去做事情的理由。</p>
</li>
<li>
<p>存在想当然的情况。没有确认清楚的情况下，想当然的认为自己明白了，或者，偷懒想当然认为可以了，不用做了。</p>
</li>
</ul>
<h2 id="2专业能力提高上存在的问题">2)专业能力提高上存在的问题</h2>
<ul>
<li>开发方案积累不够<br>
表设计、代码将同类业务抽象出来、架构设计、等等</li>
<li>缺少有效的针对基本功的训练计划</li>
<li>缺乏系统性规划的长期学习计划</li>
<li>缺少对业务快速理解与应用的一套策略</li>
<li>分析（数据、代码、表结构设计、业务关联，等等）</li>
<li>问题定位（复现以及如何去快速修正问题）</li>
<li>整理和梳理清楚所要做的事情是哪些，确定自己做这些工作所需要的工作时间是多久</li>
<li>信息整合、分析、决断、行动</li>
</ul>
<h1 id="三-新年要做的事情">三、新年要做的事情</h1>
<ul>
<li>继续健身</li>
<li>努力把工作和专业的提升做好，将自身存在的上述的种种问题解决</li>
<li>平衡好工作和生活，如果可以的话，去认识一位良人</li>
</ul>
]]></content>
    </entry>
</feed>